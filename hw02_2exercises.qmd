---
title: "Homework 2.2 Data Wrangling"
author: "Andrew Joyce"
date: "2023-09-11"
format: html
editor: visual
mainfont: "Baskerville"
embed-resources: true
---

```{r}
#| echo: false
#| results: hide
#| include: false
library(conflicted)
conflicts_prefer(dplyr::filter)
library(tidyverse)
library(nycflights13)
library(dplyr)
```

## Section 4.2.5

1.  **In a single pipeline for each condition, find all flights that meet the following condition:**

```{r}
# Had an arrival delay of 2 or more hours
flights |> 
  filter(arr_delay >= 120)

# Flew to Houston (IAH/HOU)
flights |> 
  filter(dest %in% c("IAH", "HOU"))

# Were operated by United, Delta, or American
flights |> 
  filter(carrier %in% c("UA", "DL", "AA"))

# Departed in summer (July- September)
flights |> 
  filter(month %in% c(7:9))

# Arrived more than two hours late, but didn’t leave late
flights |> 
  filter(arr_delay > 120 & dep_delay <= 0)

#Were delayed by at least an hour, but made up over 30 minutes in flight
flights |> 
  filter(dep_delay >= 60 & arr_delay < dep_delay - 30)
```

2.  **Sort `flights` to find the flights with the longest departure delays. Find the flights that left earliest in the morning.**

```{r}
# arranging flights by length of departure delay (longest to shortest) to find flights with longest departure delays
flights |> 
  arrange(desc(dep_delay))

# arranging flights by departure time (earliest to latest) to find flights that left earliest in the morning
flights |> arrange(dep_time)
```

3.  **Sort `flights` to find the fastest flights.**

```{r}
flights |> arrange(air_time)
```

4.  **Was there a flight on every day of 2013?**

```{r}
flights |> 
  distinct(month, day)
```

Because there are 365 distinct pairs of months and days, there were indeed flights every day of 2013.

5.  **Which flights traveled the farthest distance? The least distance?**

```{r}
# To view flights that traveled the farthest distance
flights |> 
  arrange(desc(distance))

# To view flights that traveled the least distance
flights |> 
  arrange(distance)
```

6.  **Does it matter what order you used `filter()` and `arrange()` if you're using both? Why/why not? Think about the results and how much work the functions would have to do.**

Yes, the order does matter- though the output is the same, the order matters in terms of computing power.

The function `arrange()` sorts every single row in the data. The function `filter()` removes rows of data.\
By using the function `filter()` first, you'll end up arranging only the rows of interest. It will be less work for the function to use `filter()` first and then use `arrange()`.

For example, I am curious about the longest departure delays from the carrier American Airlines. I will run two blocks of code: the first in the preferred `filter()` then `arrange()` sequence, and the second in the less desired `arrange()` then `filter()` sequence.

```{r}
flights |> 
  filter(carrier == "AA") |> 
  arrange(desc(dep_delay))

```

```{r}
flights |> 
  arrange(desc(dep_delay)) |> 
  filter(carrier == "AA")
```

Note that the output is the same. So in one sense, it does not matter, since we get the same answer. However, by filtering first, the work of arranging is lessened. So, if I were using a massive data set with millions of rows, I would definitely want to filter first.

## Section 4.3.5

1.  **Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?**

The variable `dep_time` describes the actual time the flight departed.\
The variable `sched_dep_time` describes the time the flight was supposed to depart.\
The variable `dep_delay` is generated by subtracting the flight's departure time from the scheduled departure time. Thus, positive values indicate flights that had a delay upon departure, and negative values indicate flights that departed earlier than scheduled.

2.  **Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.**

```{r}
# list desired columns separating with a comma
flights |> 
  select(dep_time, dep_delay, arr_time, arr_delay) 

# use a colon to select a range of columns
flights |> 
  select(dep_time, dep_delay:arr_time, arr_delay) 

#use an exclamation point to select by excluding a column or range of columns
flights |> 
  select(!(year:day) & !sched_dep_time & !sched_arr_time & !(carrier:time_hour)) 
```

3.  **What happens if you specify the name of the same variable multiple times in a `select()` call?**

If you repeat the same variable, it will only appear once in the output.

```{r}
flights |> 
  select(dep_time, dep_delay, arr_time, arr_delay, arr_time, arr_time, arr_time)
```

Though I specified `arr_time 4` separate times In the code, it only appears once in the output.

4.  **What does the `any_of()` function do? Why might it be helpful in conjunction with this vector?**

The `any_of()` function will select for any variables within a character vector. Since the function does not look for missing variables, an error will not occur if any variables are missing.

For example, take the following vector:

```         
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
```

We can use this object, a character vector titled `variables`, to select from the flights data.

```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
flights |> 
  select(any_of(variables))
```

Or, we can use the same vector to quickly exclude those variables from the data.

```{r}
flights |> 
  select(!any_of(variables))
```

Since we've created a character vector, we can reference that in our code instead of repeatedly typing the same five variables over and over.

5.  **Does the result of running the following code surprise you? How do the select helpers deal with upper and lower case by default? How can you change that default?**

```{r}
flights |> select(contains("TIME"))
```

This chunk shows any column that contains "TIME" in its name. However, the default is to ignore the case of the text. So no matter if I typed "TIME" or "time" I will get the same result. I can change this by specifying `ignore.case = FALSE` (the default is TRUE):

```{r}
flights |> select(contains("TIME", ignore.case=FALSE))
```

Because I specified within the command to *not* ignore the case of column names, no columns are returned since all the column names in the data are in lower case.

6.  **Rename `air_time` to `air_time_min` to indicate units of measurement and move it to the beginning of the data frame.**

```{r}
flights |> 
  rename(air_time_min = air_time) |> relocate(air_time_min)
```

6.  **Why doesn't the following work, and what does the error mean?**

```         
flights |> 
  select(tailnum) |> 
  arrange(arr_delay)
#> Error in `arrange()`:
#> ℹ In argument: `..1 = arr_delay`.
#> Caused by error:
#> ! object 'arr_delay' not found
```

The command `select()` chooses variables of interest. Here, the second line of code says to select only the column `tailnum`. Only one column is selected. So, the third line command to arrange by `arr_delay` fails because only one column has been selected. After `arrange()`, R is looking for an object- usually a variable name. But since we've previously selected one (and only one) column, `tailnum`, there is no object named `arr_delay` to be found.

## Section 4.5.7

1.  **Which carrier has the worst average delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about `flights |> group_by(carrier, dest) |> summarize(n())`)**

To find out which carrier has the worst average departure delay:

```{r}
flights |> 
  group_by(carrier) |> 
  summarize(avgdelay = mean(dep_delay, na.rm=TRUE)) |> 
  arrange(desc(avgdelay))

```

Frontier Airlines ([F9](https://aspm.faa.gov/aspmhelp/index/ASQP__Carrier_Codes_and_Names.html)) has the worst average departure delays.

Conceptually, It will not be easy to disentangle the effects of bad carriers versus bad airports. There are 16 distinct carriers. There are 105 distinct destinations, and 3 distinct origins. There are 224 unique routes (unique combinations of origin & destination). There are 439 total carrier-routes (unique combinations of carrier, origin, and destination).

```{r}
# number of distinct carriers, destinations, and origins
flights |> 
  summarize(n_distinct(carrier),
            n_distinct(dest),
            n_distinct(origin))

# distinct origin-destination pairs (unique routes, no matter the carrier)
flights  |> distinct(origin, dest) 

# distinct carrier routes (origin, dest, carrier pairs)
flights |> distinct(carrier, origin, dest)

# average departrue delays by carrier per airport
flights |> 
  group_by(origin, carrier) |> 
  summarize(avgdelay = mean(dep_delay, na.rm=TRUE)) |> 
  arrange(desc(avgdelay))
  
```

I'm not sure if the data can answer this question, since not every carrier takes every single route. You could look at average departure delays by carrier per airport, and that might give you a sense of what's going on, but I am not confident you could readily disentangle the effects. For example, it looks like carrier EV has consistently high delays from EWR, LGA, and JFK, so EV is an egregiously late carrier.

I'm envisioning an equation:

$$
y_{i} = \beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{2} + \epsilon
$$

Where $y_{i}$ is the predicted delay time, $\beta_{0}$ is a constant, $X_{1}$ is the variable for carrier, $X_{2}$ is the variable for airport. You could compare $\beta_{1}$ and $\beta_{2}$ to figure out which has a greater impact on delay time.

2.  **Find the flights that are most delayed upon departure from each destination.**

```{r}
flights |> 
  group_by(dest) |> 
  slice_max(dep_delay, n = 1) |>
  relocate(dest)
```

3.  **How do delays vary over the course of the day. Illustrate your answer with a plot.**

To visualize how delays vary over the course of a day, I created a scatterplot comparing hour and average departure delay.

```{r}
flights |> 
  group_by(hour) |> 
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE)) |> 
  ggplot(aes(x=hour, y=avg_delay)) + geom_point()
```

4.  **What happens if you supply a negative `n` to `slice_min()` and `slice_max()`?**

I will take from an example above where I was finding flights *most delayed* upon departure from each destination.

```{r}
# slice_max
flights |> 
  group_by(dest) |> 
  slice_max(dep_delay, n = -1) |>
  relocate(dest)

# slice_min
flights |> 
  group_by(dest) |> 
  slice_min(dep_delay, n = -1) |>
  relocate(dest)
```

Essentially, a negative `n` does not affect anything.

5.  **Explain what `count()` does in terms of the dplyr verbs you just learned. What does the `sort` argument to `count()` do?**

The command `count()` will tally the number of times a particular combination appears.

For example:

```{r}
flights |>
  count(origin, dest, sort = TRUE)
```

The above code creates a tibble showing the number of times a unique origin-destination pair appears. There were 11,262 flights that flew from JFK to LAX in 2013. The `SORT` argument arranges them in descending order.

```{r}
flights |> 
  count(origin, dest, carrier, sort = TRUE)
```

This adds an additional column carrier to find unique origin-destination-carrier combinations. These, then, are unique carrier routes. The most frequent one is from LGA to ORD, flown by AA, occurring 5,694 times.

6.  **Suppose we have the following tiny data frame:**

    ```{r}
    df <- tibble(
      x = 1:5,
      y = c("a", "b", "a", "a", "b"),
      z = c("K", "K", "L", "L", "K")
    )
    ```

    a.  **Write down what you think the output will look like, then check if you were correct, and describe what `group_by()` does.**

    ```{r}
    df |>
      group_by(y)
    ```

    The command `group_by(y)` sorts the data frame into groups based on the column `y`. Since `y` has 2 values ("a" or "b"), the tibble is grouped by `y` into two groups.

    b.  **Write down what you think the output will look like, then check if you were correct, and describe what `arrange()` does. Also comment on how it's different from the `group_by()` in part (a)?**

    ```{r}
    df |> arrange(y)
    ```

    The command `arrange()` will sort by the values of the column selected. While `group_by()` doesn't actually impact how the data appears, `arrange()` will change the order of the observations.

    c.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does.**

    ```{r}
    df |>
      group_by(y) |>
      summarize(mean_x = mean(x))
    ```

    The output will take the mean value of the column `x` separately for the two groups of `y`. The pipeline instructs R to execute any subsequent operations split by the groups specified (in this case, the two groups of y).

    d.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. Then, comment on what the message says.**

    ```{r}
    df |>
      group_by(y, z) |>
      summarize(mean_x = mean(x))
    ```

    The output will group observations into groups based on both y and z. There should be three rows- one row for when y=a & z= K, one row for when y=a & z = L, and one row for when y=b & z=K. There is not a row for when y=B and z=L since that pair does not exist in the original data frame. Again, the pipeline says for subsequent operations, sort by y and z.

    e.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. How is the output different from the one in part (d).**

    ```{r}
    df |>
      group_by(y, z) |>
      summarize(mean_x = mean(x), .groups = "drop")
    ```

    The output Is identical, except it drops the error message that `summarize()` has grouped output by `'y'`.

    f.  **Write down what you think the outputs will look like, then check if you were correct, and describe what each pipeline does. How are the outputs of the two pipelines different?**

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
```

`Summarize()` will create the mean for `x` for all the rows that form a unique combination of `(y, z)`. Since there are three unique combinations, there are three rows in the tibble.

`Mutate()` will generate a new column with the value of the mean for each unique combination of `(y, z)`. While there are three unique combinations, they occur a total of five times, so there are five rows in the tibble (and a fourth column titled `mean_x`).
