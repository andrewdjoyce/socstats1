---
title: "Homework 2.2 Data Wrangling"
author: "Andrew Joyce"
date: "2023-09-11"
format: html
editor: visual
mainfont: "Baskerville"
embed-resources: true
---

```{r}
#| echo: false
#| results: hide
#| include: false
library(conflicted)
conflicts_prefer(dplyr::filter)
library(tidyverse)
library(nycflights13)
library(dplyr)
```

## Section 4.2.5

1.  **In a single pipeline for each condition, find all flights that meet the following condition:**

```{r}
# Had an arrival delay of 2 or more hours
flights |> 
  filter(arr_delay >= 120)

# Flew to Houston (IAH/HOU)
flights |> 
  filter(dest %in% c("IAH", "HOU"))

# Were operated by United, Delta, or American
flights |> 
  filter(carrier %in% c("UA", "DL", "AA"))

# Departed in summer (July- September)
flights |> 
  filter(month %in% c(7:9))

# Arrived more than two hours late, but didn’t leave late
flights |> 
  filter(arr_delay > 120 & dep_delay <= 0)

#Were delayed by at least an hour, but made up over 30 minutes in flight
flights |> 
  filter(dep_delay >= 60 & arr_delay < dep_delay - 30)
```

2.  **Sort `flights` to find the flights with the longest departure delays. Find the flights that left earliest in the morning.**

```{r}
# arranging flights by length of departure delay (longest to shortest) to find flights with longest departure delays
flights |> 
  arrange(desc(dep_delay))

# arranging flights by departure time (earliest to latest) to find flights that left earliest in the morning
flights |> arrange(dep_time)
```

3.  **Sort `flights` to find the fastest flights.**

```{r}
flights |> arrange(air_time)
```

4.  **Was there a flight on every day of 2013?**

```{r}
flights |> 
  distinct(month, day)
```

Because there are 365 distinct pairs of months and days, there were indeed flights every day of 2013.

5.  **Which flights traveled the farthest distance? The least distance?**

```{r}
# To view flights that traveled the farthest distance
flights |> 
  arrange(desc(distance))

# To view flights that traveled the least distance
flights |> 
  arrange(distance)
```

6.  **Does it matter what order you used `filter()` and `arrange()` if you're using both? Why/why not? Think about the results and how much work the functions would have to do.**

Yes, the order does matter- though the output is the same, the order matters in terms of computing power.

The function `arrange()` sorts every single row in the data. The function `filter()` removes rows of data.\
By using the function `filter()` first, you'll end up arranging only the rows of interest. It will be less work for the function to use `filter()` first and then use `arrange()`.

For example, I am curious about the longest departure delays from the carrier American Airlines. I will run two blocks of code: the first in the preferred `filter()` then `arrange()` sequence, and the second in the less desired `arrange()` then `filter()` sequence.

```{r}
flights |> 
  filter(carrier == "AA") |> 
  arrange(desc(dep_delay))

```

```{r}
flights |> 
  arrange(desc(dep_delay)) |> 
  filter(carrier == "AA")
```

Note that the output is the same. So in one sense, it does not matter, since we get the same answer. However, by filtering first, the work of arranging is lessened. So, if I were using a massive data set with millions of rows, I would definitely want to filter first.

## Section 4.3.5

1.  **Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?**

The variable `dep_time` describes the actual time the flight departed.\
The variable `sched_dep_time` describes the time the flight was supposed to depart.\
The variable `dep_delay` is generated by subtracting the flight's departure time from the scheduled departure time. Thus, positive values indicate flights that had a delay upon departure, and negative values indicate flights that departed earlier than scheduled.

2.  **Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.**

```{r}
# list desired columns separating with a comma
flights |> 
  select(dep_time, dep_delay, arr_time, arr_delay) 

# use a colon to select a range of columns
flights |> 
  select(dep_time, dep_delay:arr_time, arr_delay) 

#use an exclamation point to select by excluding a column or range of columns
flights |> 
  select(!(year:day) & !sched_dep_time & !sched_arr_time & !(carrier:time_hour)) 
```

3.  **What happens if you specify the name of the same variable multiple times in a `select()` call?**

If you repeat the same variable, it will only appear once in the output.

```{r}
flights |> 
  select(dep_time, dep_delay, arr_time, arr_delay, arr_time, arr_time, arr_time)
```

Though I specified `arr_time 4` separate times In the code, it only appears once in the output.

4.  **What does the `any_of()` function do? Why might it be helpful in conjunction with this vector?**

The `any_of()` function will select for any variables within a character vector. Since the function does not look for missing variables, an error will not occur if any variables are missing.

For example, take the following vector:

```         
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
```

We can use this object, a character vector titled `variables`, to select from the flights data.

```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
flights |> 
  select(any_of(variables))
```

Or, we can use the same vector to quickly exclude those variables from the data.

```{r}
flights |> 
  select(!any_of(variables))
```

Since we've created a character vector, we can reference that in our code instead of repeatedly typing the same five variables over and over.

5.  **Does the result of running the following code surprise you? How do the select helpers deal with upper and lower case by default? How can you change that default?**

```{r}
flights |> select(contains("TIME"))
```

This chunk shows any column that contains "TIME" in its name. However, the default is to ignore the case of the text. So no matter if I typed "TIME" or "time" I will get the same result. I can change this by specifying `ignore.case = FALSE` (the default is TRUE):

```{r}
flights |> select(contains("TIME", ignore.case=FALSE))
```

Because I specified within the command to *not* ignore the case of column names, no columns are returned since all the column names in the data are in lower case.

6.  **Rename `air_time` to `air_time_min` to indicate units of measurement and move it to the beginning of the data frame.**

```{r}
flights |> 
  rename(air_time_min = air_time) |> relocate(air_time_min)
```

6.  **Why doesn't the following work, and what does the error mean?**

```         
flights |> 
  select(tailnum) |> 
  arrange(arr_delay)
#> Error in `arrange()`:
#> ℹ In argument: `..1 = arr_delay`.
#> Caused by error:
#> ! object 'arr_delay' not found
```

The command `select()` chooses variables of interest. Here, the second line of code says to select only the column `tailnum`. Only one column is selected. So, the third line command to arrange by `arr_delay` fails because only one column has been selected. After `arrange()`, R is looking for an object- usually a variable name. But since we've previously selected one (and only one) column, `tailnum`, there is no object named `arr_delay` to be found.

## Section 4.5.7

1.  **Which carrier has the worst average delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about `flights |> group_by(carrier, dest) |> summarize(n())`)**

To find out which carrier has the worst average departure delay:

```{r}
flights |> 
  group_by(carrier) |> 
  summarize(avgdelay = mean(dep_delay, na.rm=TRUE)) |> 
  arrange(desc(avgdelay))

```

Frontier Airlines ([F9](https://aspm.faa.gov/aspmhelp/index/ASQP__Carrier_Codes_and_Names.html)) has the worst average departure delays.

Conceptually, It will not be easy to disentangle the effects of bad carriers versus bad airports. There are 16 distinct carriers. There are 105 distinct destinations, and 3 distinct origins. There are 224 unique routes (unique combinations of origin & destination). There are 439 total carrier-routes (unique combinations of carrier, origin, and destination).

```{r}
# number of distinct carriers, destinations, and origins
flights |> 
  summarize(n_distinct(carrier),
            n_distinct(dest),
            n_distinct(origin))

# distinct origin-destination pairs (unique routes, no matter the carrier)
flights  |> distinct(origin, dest) 

# distinct carrier routes (origin, dest, carrier pairs)
flights |> distinct(carrier, origin, dest)
```

If I compared raw average delays by carrier, I'd ignore airport effects.

If I compared raw average delays by airport, I'd ignore carrier effects.

So...list average delays per airport per carrier. I can first look at sort by average departure delay for each origin airport by carrier.

```{r}
## Find average departure delay for each flight by carrier.

## Find average departure delay for each flight by airport.

  


```

2.  **Find the flights that are most delayed upon departure from each destination.**

```{r}
flights |> 
  group_by(dest) |> 
  slice_max(dep_delay, n = 1) |>
  relocate(dest)
```

3.  **How do delays vary over the course of the day. Illustrate your answer with a plot.**

To visualize how delays vary over the course of a day, I created a scatterplot comparing hour and departure delay. This will show pairs

```{r}
ggplot (
  data = flights,
  mapping = aes(x = hour, y = dep_delay )
) +
  geom_point() 
```

4.  **What happens if you supply a negative `n` to `slice_min()` and `slice_max()`?**

5.  **Explain what [`count()`](https://dplyr.tidyverse.org/reference/count.html) does in terms of the dplyr verbs you just learned. What does the `sort`argument to [`count()`](https://dplyr.tidyverse.org/reference/count.html) do?**

6.  **Suppose we have the following tiny data frame:**

    ```         
    df <- tibble(
      x = 1:5,
      y = c("a", "b", "a", "a", "b"),
      z = c("K", "K", "L", "L", "K")
    )
    ```

    a.  **Write down what you think the output will look like, then check if you were correct, and describe what `group_by()` does.**

        ```         
        df |>
          group_by(y)
        ```

    b.  **Write down what you think the output will look like, then check if you were correct, and describe what `arrange()` does. Also comment on how it's different from the `group_by()` in part (a)?**

        ```         
        df |>
          arrange(y)
        ```

    c.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does.**

        ```         
        df |>
          group_by(y) |>
          summarize(mean_x = mean(x))
        ```

    d.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. Then, comment on what the message says.**

        ```         
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x))
        ```

    e.  **Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. How is the output different from the one in part (d).**

        ```         
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x), .groups = "drop")
        ```

    f.  **Write down what you think the outputs will look like, then check if you were correct, and describe what each pipeline does. How are the outputs of the two pipelines different?**

        ```         
        df |>
          group_by(y, z) |>
          summarize(mean_x = mean(x))

        df |>
          group_by(y, z) |>
          mutate(mean_x = mean(x))
        ```
